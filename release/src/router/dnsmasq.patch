Jon Zarate AFAIK wrote the original Tomato specific code, primarily to
support extra info in the GUI. Following is a vague clue as to how it
hangs together.

device list status is handled by www/devlist.c - this sends a SIGUSR2
to dnsmasq which causes the 'tomato_helper' function to execute in
addition to the normal dnsmasq SIGUSR2 code (Switch logfile, but since
Tomato not using that it doesn't matter) devlist.c waits up to 5 secs
for file '/var/tmp/dhcp/leases.!' to disappear before continuing
(Must be a better way to do this IPC stuff)

tomato_helper(lease.c) does a couple of things:

It looks for /var/tmp/dhcp/delete and deletes any known leases by IP
address found therein.  It deletes /var/tmp/dhcp/delete when done.
This implements the 'delete lease' from GUI functionality.

It dumps the current dhcp leases into /var/tmp/dhcp/lease.! (tmp file)
subtracting the current time from the lease expiry time, thus producing
a 'lease remaining' time for the GUI.
The temp file is renamed to /var/tmp/dhcp/leases thus signalling devlist.c
that it may proceed.  Finally when devlist.c is finished
/var/tmp/dhcp/leases is removed.

dnsmasq.c also intercepts SIGHUP so that it may flush the lease file.
This is so lease expiry times survive a process restart since dnsmasq
reads the lease file at start-up.

Finally(?) lease_update_file (lease.c) writes out the remaining lease
duration for each dhcp lease rather than lease expiry time (with RTC) or
lease length (no RTC) for dnsmasq's internal lease database.

dhcp lease file is /var/lib/misc/dnsmasq.leases

Above description K Darbyshire-Bryant 04/12/13

diff --git a/bld/get-version b/bld/get-version
index c246a3c..2352a2f 100755
--- a/bld/get-version
+++ b/bld/get-version
@@ -11,7 +11,7 @@
 # If there is more than one v[0-9].* tag, sort them and use the
 # first. This favours, eg v2.63 over 2.63rc6.

-if which git >/dev/null 2>&1 && [ -d $1/.git ]; then
+if which git >/dev/null 2>&1 && [ -e $1/.git ]; then
      cd $1; git describe | sed 's/^v//'
 elif grep '\$Format:%d\$' $1/VERSION >/dev/null 2>&1; then
 # unsubstituted VERSION, but no git available.
diff --git a/src/config.h b/src/config.h
index 145820a..12e5881 100644
--- a/src/config.h
+++ b/src/config.h
@@ -67,6 +67,10 @@ HAVE_BROKEN_RTC
    NOTE: when enabling or disabling this, be sure to delete any old
    leases file, otherwise dnsmasq may get very confused.
 
+HAVE_LEASEFILE_EXPIRE
+
+HAVE_TOMATO
+
 HAVE_TFTP
    define this to get dnsmasq's built-in TFTP server.
 
@@ -349,6 +353,10 @@ HAVE_SOCKADDR_SA_LEN
 #undef HAVE_IPSET
 #endif
 
+#ifdef HAVE_TOMATO
+#define HAVE_LEASEFILE_EXPIRE
+#endif
+
 #ifdef NO_LOOP
 #undef HAVE_LOOP
 #endif
@@ -415,6 +423,9 @@ static char *compile_opts =
 "no-"
 #endif
 "ipset "
+#ifdef HAVE_TOMATO
+"tomato-helper "
+#endif
 #ifndef HAVE_AUTH
 "no-"
 #endif
diff --git a/src/dnsmasq.c b/src/dnsmasq.c
index f4a89fc..5f36880 100644
--- a/src/dnsmasq.c
+++ b/src/dnsmasq.c
@@ -1240,6 +1240,19 @@ static void async_event(int pipe, time_t now)
 	   we leave them logging to the old file. */
 	if (daemon->log_file != NULL)
 	  log_reopen(daemon->log_file);
+#ifdef HAVE_TOMATO
+	tomato_helper(now); // possibly delete & write out leases for tomato
+#endif
+/* following is Asus tweak.  Interestingly Asus read the dnsmasq leases db
+ * directly.  They signal dnsmasq to update via SIGUSR2 and wait 1 second
+ * assuming the file will be complete by the time they come to parse it.
+ * Race conditions anyone?  What if dnsmasq happens to be updating the
+ * file anyway?
+ */
+#if defined(HAVE_DHCP) && defined(HAVE_LEASEFILE_EXPIRE) && !defined(HAVE_TOMATO)
+	if (daemon->dhcp || daemon->dhcp6)
+	    flush_lease_file(now);
+#endif
 	break;
 
       case EVENT_NEWADDR:
@@ -1272,6 +1285,11 @@ static void async_event(int pipe, time_t now)
 	  }
 #endif
 	
+#if defined(HAVE_DHCP) && defined(HAVE_LEASEFILE_EXPIRE)
+	/* Originally TOMATO tweak (TODO: is this necessary?) */
+	if (daemon->dhcp || daemon->dhcp6)
+	    flush_lease_file(now);
+#endif
 	if (daemon->lease_stream)
 	  fclose(daemon->lease_stream);
 
diff --git a/src/dnsmasq.h b/src/dnsmasq.h
index a1ac1d1..31d2d66 100644
--- a/src/dnsmasq.h
+++ b/src/dnsmasq.h
@@ -1303,6 +1303,12 @@ unsigned char *extended_hwaddr(int hwtype, int hwlen, unsigned char *hwaddr,
 int make_icmp_sock(void);
 int icmp_ping(struct in_addr addr);
 #endif
+#ifdef HAVE_TOMATO
+void tomato_helper(time_t now);
+#endif
+#ifdef HAVE_LEASEFILE_EXPIRE //originally TOMATO option
+void flush_lease_file(time_t now);
+#endif
 void queue_event(int event);
 void send_alarm(time_t event, time_t now);
 void send_event(int fd, int event, int data, char *msg);
diff --git a/src/lease.c b/src/lease.c
index 5d56b1b..e49fd41 100644
--- a/src/lease.c
+++ b/src/lease.c
@@ -133,12 +133,14 @@ void lease_init(time_t now)
 	if (!lease)
 	  die (_("too many stored leases"), NULL, EC_MISC);
        	
-#ifdef HAVE_BROKEN_RTC
+#if defined(HAVE_BROKEN_RTC) || defined(HAVE_LEAVEFILE_EXPIRE)
 	if (ei != 0)
 	  lease->expires = (time_t)ei + now;
 	else
 	  lease->expires = (time_t)0;
+#ifdef HAVE_BROKEN_RTC
 	lease->length = ei;
+#endif
 #else
 	/* strictly time_t is opaque, but this hack should work on all sane systems,
 	   even when sizeof(time_t) == 8 */
@@ -230,7 +232,12 @@ void lease_update_file(time_t now)
 	    continue;
 #endif
 
-#ifdef HAVE_BROKEN_RTC
+#ifdef HAVE_LEASEFILE_EXPIRE
+	  ourprintf(&err, "%u ", 
+		  (lease->length == 0) ? 0 :
+		  (lease->expires == 0) ? 0 :
+		  (unsigned int)difftime(lease->expires, now));
+#elif defined(HAVE_BROKEN_RTC)
 	  ourprintf(&err, "%u ", lease->length);
 #else
 	  ourprintf(&err, "%lu ", (unsigned long)lease->expires);
@@ -274,7 +281,12 @@ void lease_update_file(time_t now)
 	      if (!(lease->flags & (LEASE_TA | LEASE_NA)))
 		continue;
 
-#ifdef HAVE_BROKEN_RTC
+#ifdef HAVE_LEASEFILE_EXPIRE
+	      ourprintf(&err, "%u ", 
+		  (lease->length == 0) ? 0 :
+		  (lease->expires == 0) ? 0 :
+		  (unsigned int)difftime(lease->expires, now));
+#elif defined(HAVE_BROKEN_RTC)
 	      ourprintf(&err, "%u ", lease->length);
 #else
 	      ourprintf(&err, "%lu ", (unsigned long)lease->expires);
@@ -1147,6 +1159,73 @@ void lease_add_extradata(struct dhcp_lease *lease, unsigned char *data, unsigned
 }
 #endif
 
+#ifdef HAVE_TOMATO
+void tomato_helper(time_t now)
+{
+    FILE *f;
+    struct in_addr ia;
+    char buf[64];
+    struct dhcp_lease *lease;
+
+    // if delete exists...
+    if ((f = fopen("/var/tmp/dhcp/delete", "r")) != NULL) {
+	while (fgets(buf, sizeof(buf), f)) {
+	    ia.s_addr = inet_addr(buf);
+	    lease = lease_find_by_addr(ia);
+	    if (lease) {
+		lease_prune(lease, 0);
+		lease_update_file(now);
+	    }
+	}
+	fclose(f);
+	unlink("/var/tmp/dhcp/delete");
+    }
+
+    // dump the leases file
+    if ((f = fopen("/var/tmp/dhcp/leases.!", "w")) != NULL) {
+	for (lease = leases; lease; lease = lease->next) {
+	    if (lease->hwaddr_type == ARPHRD_ETHER) {
+#ifdef HAVE_DHCP6 //only dump dhcpv6 if we have it
+		if (lease->flags & (LEASE_TA | LEASE_NA))
+		    inet_ntop(AF_INET6, &lease->addr6, buf, ADDRSTRLEN);
+		else
+#endif // Thanks to Shibby :-)
+		    inet_ntop(AF_INET, &lease->addr, buf, ADDRSTRLEN);
+
+		fprintf(f, "%lu %02X:%02X:%02X:%02X:%02X:%02X %s",
+			lease->expires - now,
+			lease->hwaddr[0], lease->hwaddr[1], lease->hwaddr[2], lease->hwaddr[3], lease->hwaddr[4], lease->hwaddr[5],
+			buf);
+		if (lease->fqdn)
+		    fprintf(f, "%s\n", lease->fqdn);
+		else if (!option_bool(OPT_DHCP_FQDN) && lease->hostname && strlen(lease->hostname) > 0)
+		    fprintf(f, "%s\n", lease->hostname);
+		else
+		    fprintf(f, "*\n");
+	    }
+	}
+	fclose(f);
+	rename("/var/tmp/dhcp/leases.!", "/var/tmp/dhcp/leases");
+    }
+}
+#endif //HAVE_TOMATO
+
+#ifdef HAVE_LEASEFILE_EXPIRE
+void flush_lease_file(time_t now)
+{
+    static time_t flush_time = (time_t)0;
+
+    if(difftime(flush_time, now) < 0)
+	file_dirty = 1;
+
+    lease_prune(NULL, now);
+    lease_update_file(now);
+
+    if (file_dirty == 0)
+	flush_time = now;
+}
+#endif //HAVE_LEASEFILE_EXPIRE
+
 #endif
 	  
 
